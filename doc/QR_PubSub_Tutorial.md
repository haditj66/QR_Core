# üìò Tutorial: Setting Up QR and NonQR Publishers and Subscribers

This tutorial explains **how to configure publishers and subscribers** in your AERTOS/QR-Core environment ‚Äî both standard **QR-based** events and **NonQR publishers** (for external ROS messages).  
Examples are drawn directly from real project configs such as `cablecam/config/cablecam.cs`.

---

## üß© Section 1: Configuring QR Publishers and Subscribers

### 1. Overview

QR-based publishers and subscribers are defined directly in node classes that inherit from **`AONode<T>`** or **`AOSurrogateNode<T>`**.  
These declarations tell the AERTOS generator which events to create and how to link them across the system.

### 2. Example Node Definition

```csharp
public class TestSimple : AONode<TestSimple>
{
    public TestSimple(string instanceName) : base(instanceName)
    {
    }

    // Define timers (optional)
    public override List<ROSTimer> SetAllTimers()
    {
        return new List<ROSTimer>()
        {
            new ROSTimer("testTimer", 1000)
        };
    }

    // Define publishers
    public override List<ROSPublisher> SetAllPublishers()
    {
        return new List<ROSPublisher>()
        {
            ROSPublisher.CreatePublisher(
                "pub1",
                new QREventMSGTemplate<int>("SomeTestEvent", "somesize"),
                true
            )
        };
    }

    // Define subscribers
    public override List<ROSSubscriber> SetAllSubscribers()
    {
        return new List<ROSSubscriber>()
        {
            ROSSubscriber.CreateSubscriber<int>(
                "sub1",
                "SomeTestEvent",
                OnSomeTestEvent
            )
        };
    }

    private void OnSomeTestEvent(int value)
    {
        Console.WriteLine($"Received event value: {value}");
    }
}
```

### 3. Notes

| Element | Description |
|----------|--------------|
| `ROSPublisher.CreatePublisher()` | Defines a new QR event publisher. |
| `QREventMSGTemplate<T>()` | Defines the payload type and event name. |
| `ROSSubscriber.CreateSubscriber()` | Creates a subscription to the same event. |
| `OnSomeTestEvent()` | The callback that executes when an event is received. |

The code generator will convert these lists into **C++/ROS2 publishers and subscribers**, automatically handling all serialization and topic creation.

---

## ‚öôÔ∏è Section 2: Configuring NonQR Publishers

### 1. Overview

**NonQR publishers** allow your project to use existing ROS 2 messages and topics that were **not generated by AERTOS**.  
They are mapped manually using `QRTarget_NonQR`, linking C# logic to external ROS 2 message types.

### 2. Example from `cablecam/config/cablecam.cs`

```csharp
QRTarget_NonQR qRTarget_NonQR = new QRTarget_NonQR(
    "cablecam", "odrive_can", "ros_odrive",
    Path.Combine("ros_odrive", "odrive_node", "srv"),
    Path.Combine("ros_odrive", "odrive_node", "msg"),
    new List<NonQrServiceFunction>() {
        new NonQrServiceFunction("AxisState", "request_axis_state")
    },
    new List<NonQrMessage>() {
        new NonQrMessage(
            "ControlMessage",
            "odrive_axis0/control_message",
            "#include \"odrive_can/msg/control_message.hpp\"",
            "odrive_can::msg::ControlMessage")
    }
);
```

### 3. Explanation

| Field | Description |
|--------|--------------|
| `"cablecam"` | The module name. |
| `"odrive_can"` | The external ROS 2 package providing message definitions. |
| `"ControlMessage"` | Logical name used inside your AONode. |
| `"odrive_axis0/control_message"` | Actual ROS 2 topic name. |
| `#include "odrive_can/msg/control_message.hpp"` | Header included in generated C++ code. |
| `odrive_can::msg::ControlMessage` | Fully-qualified ROS 2 message type. |

### 4. Using the NonQR Publisher in a Node

```csharp
public class Cablecamobject : AONode<Cablecamobject>
{
    public Cablecamobject(string instanceName) : base(instanceName)
    {
    }

    public override List<ROSPublisher> SetAllPublishers()
    {
        return new List<ROSPublisher>()
        {
            ROSPublisher.GetPublisherOfName("ControlMessage")
        };
    }

    public override List<ROSSubscriber> SetAllSubscribers()
    {
        return new List<ROSSubscriber>()
        {
            ROSSubscriber.CreateSubscriber(
                "controlmsg",
                ROSPublisher.GetPublisherOfName("ControlMessage"))
        };
    }
}
```

### 5. Result in C++

After code generation, this configuration produces code equivalent to:

```cpp
#include "odrive_can/msg/control_message.hpp"

auto pub_control = node_->create_publisher<odrive_can::msg::ControlMessage>(
    "odrive_axis0/control_message", 10);

auto sub_control = node_->create_subscription<odrive_can::msg::ControlMessage>(
    "odrive_axis0/control_message", 10,
    std::bind(&Cablecamobject::OnControlMessage, this, std::placeholders::_1));
```

This is automatically generated from your C# configuration ‚Äî no manual C++ editing is required.

---

## ‚úÖ Summary

| Type | Defined In | API Used | Output |
|------|-------------|----------|---------|
| **QR Publisher/Subscriber** | `AONode<T>` | `CreatePublisher`, `CreateSubscriber` | New AERTOS message topics |
| **NonQR Publisher/Subscriber** | `QRTarget_NonQR` | `GetPublisherOfName` | External ROS 2 message bindings |

By combining these two systems, you can publish internal simulation events and bridge to existing ROS topics seamlessly.
