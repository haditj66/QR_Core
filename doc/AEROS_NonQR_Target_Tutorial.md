# üåê Tutorial: Creating a NonQR Target in AEROS / QR-Core

This tutorial explains how to **create and configure a NonQR target** in your C# configuration file.  
A NonQR target allows your AEROS module to integrate **existing ROS 2 message types and services** that were not auto-generated by AEROS.

---

## üß© Section 1: What a NonQR Target Is

In AEROS, standard QR modules define all message types internally through the generator.  
However, many robotics systems rely on external ROS 2 packages (for example, `odrive_can`, `nav_msgs`, `sensor_msgs`, etc.).  

A **NonQR Target** tells the AEROS generator:

> ‚ÄúUse an external ROS 2 message or service instead of generating one.‚Äù

This enables your QR modules to subscribe to, publish, or call existing ROS 2 topics and services seamlessly.

---

## ‚öôÔ∏è Section 2: Creating a NonQR Target

You define a NonQR target inside your `QRModule`-derived class (for example, `cablecam`).  
Below is the real pattern used in your `cablecam/config/cablecam.cs` file.

```csharp
QRTarget_NonQR qRTarget_NonQR = new QRTarget_NonQR(
    "cablecam",                      // Module name
    "odrive_can",                    // External ROS 2 package name
    "ros_odrive",                    // Folder name / build label
    Path.Combine("ros_odrive", "odrive_node", "srv"), // Path to service definitions
    Path.Combine("ros_odrive", "odrive_node", "msg"), // Path to message definitions
    new List<NonQrServiceFunction>() {
        new NonQrServiceFunction("AxisState", "request_axis_state")
    },
    new List<NonQrMessage>() {
        new NonQrMessage(
            "ControlMessage",                           // Internal AEROS name
            "odrive_axis0/control_message",              // Actual ROS topic name
            "#include \"odrive_can/msg/control_message.hpp\"", // Include header
            "odrive_can::msg::ControlMessage"            // Full C++ type
        )
    }
);
```

---

### üß† Understanding Each Parameter

| Argument | Description |
|-----------|-------------|
| `"cablecam"` | The **AEROS module name** that this target belongs to. |
| `"odrive_can"` | The **external ROS 2 package** providing the message/service definitions. |
| `"ros_odrive"` | Logical build folder used for generated code organization. |
| `Path.Combine("ros_odrive", "odrive_node", "srv")` | Directory path to ROS 2 service definitions. |
| `Path.Combine("ros_odrive", "odrive_node", "msg")` | Directory path to ROS 2 message definitions. |
| `new NonQrServiceFunction(...)` | Describes one or more external ROS 2 services. |
| `new NonQrMessage(...)` | Describes one or more external ROS 2 message types. |

---

### üîç Example: `NonQrMessage`

```csharp
new NonQrMessage(
    "ControlMessage",                           // Internal AEROS name
    "odrive_axis0/control_message",              // ROS topic name
    "#include \"odrive_can/msg/control_message.hpp\"", // Include directive for C++
    "odrive_can::msg::ControlMessage"            // Full ROS 2 message type
)
```

This tells AEROS that whenever your code calls  
`ROSPublisher.GetPublisherOfName("ControlMessage")`,  
it should use the **existing ROS 2 message** `odrive_can::msg::ControlMessage`  
and publish on the topic `/odrive_axis0/control_message`.

---

### üîß Example: `NonQrServiceFunction`

```csharp
new NonQrServiceFunction("AxisState", "request_axis_state")
```

This links an existing service from `odrive_can` that you can later call or expose inside your module.

---

## üß± Section 3: Using the NonQR Target in Your Node

Once the NonQR target is defined, you can use its messages in any node via `ROSPublisher.GetPublisherOfName()`:

```csharp
public class Cablecamobject : AONode<Cablecamobject>
{
    public Cablecamobject(string instanceName) : base(instanceName)
    {
    }

    public override List<ROSPublisher> SetAllPublishers()
    {
        return new List<ROSPublisher>()
        {
            ROSPublisher.GetPublisherOfName("ControlMessage")
        };
    }

    public override List<ROSSubscriber> SetAllSubscribers()
    {
        return new List<ROSSubscriber>()
        {
            ROSSubscriber.CreateSubscriber(
                "controlmsg",
                ROSPublisher.GetPublisherOfName("ControlMessage"))
        };
    }
}
```

This configuration binds your `Cablecamobject` node to the external ROS 2 topic defined in your NonQR target.

---

## üß∞ Section 4: How It Appears in Generated C++ Code

After running the generator, the NonQR message and service definitions are linked directly into your C++ output.

### Generated Example (simplified)

```cpp
#include "odrive_can/msg/control_message.hpp"
#include "rclcpp/rclcpp.hpp"

void Cablecamobject::Init()
{
    // Publisher for external message
    pub_control_ = node_->create_publisher<odrive_can::msg::ControlMessage>(
        "odrive_axis0/control_message", 10);

    // Subscriber for the same external message
    sub_control_ = node_->create_subscription<odrive_can::msg::ControlMessage>(
        "odrive_axis0/control_message", 10,
        std::bind(&Cablecamobject::OnControlMessage, this, std::placeholders::_1));
}

void Cablecamobject::OnControlMessage(const odrive_can::msg::ControlMessage::SharedPtr msg)
{
    RCLCPP_INFO(rclcpp::get_logger("Cablecamobject"), "Received external ControlMessage.");
}
```

‚úÖ **What‚Äôs happening:**

- AEROS automatically inserts the correct include:  
  `#include "odrive_can/msg/control_message.hpp"`
- The topic name (`odrive_axis0/control_message`) comes from your NonQR mapping.
- Both publisher and subscriber use the external ROS 2 type `odrive_can::msg::ControlMessage`.

---

## üß† Section 5: Summary

| Step | What You Do | Effect |
|------|--------------|--------|
| 1 | Define `QRTarget_NonQR` in your module | Registers external ROS package and message types |
| 2 | Add `NonQrMessage` entries | Maps message names to external topics |
| 3 | Reference them in nodes | Use `GetPublisherOfName()` / `CreateSubscriber()` |
| 4 | Run the generator | Produces working C++ code using external message definitions |

---

## ‚úÖ Example Integration Flow

1. Define NonQR target (maps ROS package).  
2. Define node (fetches publisher/subscriber from NonQR target).  
3. Run generator (`macro2`).  
4. Generated C++ code now uses the external ROS 2 message seamlessly.

---

**You now know how to create and use NonQR targets in AEROS / QR-Core!**
